var documenterSearchIndex = {"docs":
[{"location":"MP2RAGE/mp2rage_slice_profile/#Correction-of-Slab/Slice-Profile","page":"Slab profile correction","title":"Correction of Slab/Slice Profile","text":"","category":"section"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"Here, we show how to correct the errors generated by the slice/slab profile of the excitation pulse.","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/#Corrupted-MP2RAGE-image","page":"Slab profile correction","title":"Corrupted MP2RAGE image","text":"","category":"section"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"using QuantitativeMRI\nusing JLD2, CairoMakie\nd = load(joinpath(pwd(),\"../..\",\"data\",\"corrupted.jld2\"))\n\nMP2RAGE = d[\"MP2RAGE\"]\nT1map = d[\"T1map\"]\np_MP2 = d[\"params_MP2RAGE\"]\nangle_profile = d[\"angle_profile\"]\nTI1 = d[\"im_reco\"][:,:,1]\nTI2 = d[\"im_reco\"][:,:,2]\n\nf=Figure(size=(300,300))\nax = Axis(f[1,1], title=\"Corrupted MP2RAGE image\",xlabel=\"phase encoding direction\", ylabel=\"partition encoding direction\",aspect = 1)\nheatmap!(ax,MP2RAGE,colormap=:grays)\nhidedecorations!(ax,label=false)\nf","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"You can see that the image is corrupted by the slab profile of the excitation pulse along the Y axis, which corresponds to the partition encoding direction.","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"This is due to an inappropriate choice of excitation pulse—here, a Hermite shape. We can take a look at the corresponding excitation profile:","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"f=Figure(size=(300,200))\nax = Axis(f[1,1], title=\"Corrupted MP2RAGE image\",xlabel=\"partition encoding direction\", ylabel=\"effective flip angle [degrees]\")\nlines!(ax,angle_profile)\nf","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/#Fixing-the-T1-Map","page":"Slab profile correction","title":"Fixing the T1 Map","text":"","category":"section"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"Fortunately, if we know the effective flip angle profile, we can correct the resulting T1 map.","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"p = deepcopy(p_MP2)\n\nT1corr = similar(MP2RAGE)\nT1,range_T1,LUT = mp2rage_T1maps(MP2RAGE,p_MP2)\n\nLUT_vec = []\nrange_T1_vec = []\nfor i=1:size(MP2RAGE,2)\n  p.α₁ = d[\"angle_profile\"][i]\n  p.α₂ = d[\"angle_profile\"][i] ./ p_MP2.α₁ .* p_MP2.α₂\n\n  T1corr[:,i], range_T1, LUT= mp2rage_T1maps(MP2RAGE[:,i],p)\n  push!(LUT_vec,LUT)\n  push!(range_T1_vec,range_T1)\nend\n\nf=Figure(size=(400,300))\nax = Axis(f[1,1], title=\"Initial T1 map\",aspect = 1)\nheatmap!(ax,T1,colorrange = (800,2000))\nhidedecorations!(ax)\nax = Axis(f[1,2], title=\"Corrected T1 map\",aspect = 1)\nh=heatmap!(ax,T1corr,colorrange = (800,2000))\nhidedecorations!(ax)\nColorbar(f[1,3], h, label=\"T1 [ms]\",tellheight=true)\nrowsize!(f.layout, 1, ax.scene.px_area[].widths[2])\nf","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"The idea is to compute a different lookup table (LUT) for each partition position, using the effective flip angle profile. This allows us to correct the T1 map for the slab profile effect.","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"Let's take a look at two different LUTs:","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"f=Figure(size=(400,300))\nax = Axis(f[1,1], title=\"LUT for partition position 1 and 96\")\nxlims!(ax,0,range_T1_vec[96][end])\nylims!(ax,-0.5,0.5)\n\nlines!(ax,range_T1_vec[1],LUT_vec[1],label=\"angle = $(angle_profile[1])\",color=:blue)\nlines!(ax,range_T1_vec[96],LUT_vec[96],label=\"angle = $(angle_profile[96])\",color=:green)\n\nval_MP2 = 0.1\nidxFirst1 = searchsortedfirst(LUT_vec[1], val_MP2,lt= >=)\nidxFirst2 = searchsortedfirst(LUT_vec[96], val_MP2,lt= >=)\nhlines!(ax,val_MP2,xmax=range_T1_vec[96][idxFirst2]/range_T1_vec[96][end],color=:red,linestyle=:dot)\n\nvlines!(ax,range_T1_vec[1][idxFirst1],color=:blue,linestyle=:dash)\nvlines!(ax,range_T1_vec[96][idxFirst2],color=:green,linestyle=:dash)\nf","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"You can see that the different effective flip angle profiles lead to different LUTs, which allows us to correct the T1 map for the slab profile effect.","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/#Correcting-the-MP2RAGE-Image","page":"Slab profile correction","title":"Correcting the MP2RAGE Image","text":"","category":"section"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"We can also correct the MP2RAGE image using the corrected T1 map.","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"res = QuantitativeMRI.T1maps_mp2rage(T1corr,p_MP2) \n\n\nbegin\n  sl=[:,:]\n  f = Figure()\n\n  ax=Axis(f[1,1],title=\"Initial MP2RAGE\",aspect = 1)\n  h=heatmap!(ax,MP2RAGE,colormap=:grays)\n\n  ax=Axis(f[1,2],title=\"corrected MP2RAGE\",aspect = 1)\n  h=heatmap!(ax,res[1], colormap=:grays)\n\n  for ax in f.content   # hide decoration befor adding colorbar\n    hidedecorations!(ax)\n  end\n\n  f\nend","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"As you can see, the corrected MP2RAGE image is now free of the slab profile effect.","category":"page"},{"location":"MP2RAGE/mp2rage_slice_profile/","page":"Slab profile correction","title":"Slab profile correction","text":"Unfortunately, we cannot generate the corrected TI₁ and TI₂ images from the corrected T1 map. Even if we are able to generate the signal equation knowing the T1 map, we would also need to know the T2*, B1-, and proton density for each voxel.","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"Here, we show how to reconstruct T1 maps from MP2RAGE images using the QuantitativeMRI.jl package.","category":"page"},{"location":"MP2RAGE/mp2rage/#Step-1:-Convert-TI-Images-to-MP2RAGE-/-UNI-Image","page":"Standard reconstruction","title":"Step 1: Convert TI Images to MP2RAGE / UNI Image","text":"","category":"section"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"We load the MP2RAGE dataset, which contains the two TI images.","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"using QuantitativeMRI\nusing JLD2, CairoMakie\nd = load(joinpath(pwd(),\"../..\",\"data\",\"mp2rage.jld2\"))\n\nim_reco = d[\"im_reco\"]\n\nf=Figure(size=(800,600))\nax = Axis(f[1,1], title=\"TI1 image\",aspect=1)\nheatmap!(ax,abs.(im_reco[:,:,1]),colormap=:grays)\nax = Axis(f[1,2], title=\"TI2 image\",aspect=1)\nheatmap!(ax,abs.(im_reco[:,:,2]),colormap=:grays)\nfor ax in f.content\n  hidedecorations!(ax)\nend\nf","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"We need to compute the MP2RAGE / UNI image using the function mp2rage_comb. This function expects the two TI images to be along the last dimension.","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"For example, if you have multiple repetitions, you need to permute your images so that the TI images are along the last dimension.","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"In our case, the images are in complex format, but if you have the magnitude and phase images, you can use the same function with MP2 = mp2rage_comb(magnitude, phase).","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"MP2 = mp2rage_comb(im_reco)\nheatmap(MP2,colormap=:grays)","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"The data range is now between -0.5 and 0.5.","category":"page"},{"location":"MP2RAGE/mp2rage/#Step-2:-Compute-T1-Maps","page":"Standard reconstruction","title":"Step 2: Compute T1 Maps","text":"","category":"section"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"Now, we can compute the T1 maps using the function mp2rage_T1maps. This function expects the MP2RAGE image and the parameters of the MP2RAGE sequence.","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"The MP2RAGE parameters are stored in the ParamsMP2RAGE structure.","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"help?> ParamsMP2RAGE\n\n  mutable struct ParamsMP2RAGE\n\n  Fields\n  ≡≡≡≡≡≡\n\n  TI₁        :: Float64\n  TI₂        :: Float64\n  TR         :: Float64\n  MP2RAGE_TR :: Float64\n  ETL        :: Int64\n  α₁         :: Float64\n  α₂         :: Float64","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"p = ParamsMP2RAGE(\n  800,\n  2250,\n  6.5,\n  5000,\n  128,\n  7,\n  7\n)","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"You can compute the corresponding look-up table (LUT) for Cartesian encoding using mp2rage_lookuptable_cartesian(p::ParamsMP2RAGE; T1Range=1:0.5:10000, effInv=0.96) or for radial encoding with mp2rage_lookuptable_radial.","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"Alternatively, you can directly compute the T1 maps as well as the LUT with mp2rage_T1maps(MP2, p).","category":"page"},{"location":"MP2RAGE/mp2rage/","page":"Standard reconstruction","title":"Standard reconstruction","text":"T1, range_T1, LUT = mp2rage_T1maps(MP2,p,T1Range=1:0.5:5000,effInv = 0.96)\n\nf=Figure()\nax = Axis(f[1,1], title=\"T1 map\")\nheatmap!(ax,T1,colorrange = (800,2000))\nax= Axis(f[1,2], title=\"LUT\",xlabel=\"T1 [ms]\", ylabel=\"MP2RAGE signal [a.u.]\")\nlines!(ax,range_T1,LUT)\nf","category":"page"},{"location":"#QuantitativeMRI","page":"Home","title":"QuantitativeMRI","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuantitativeMRI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#QuantitativeMRI.MESE_EPG-NTuple{5, Any}","page":"Home","title":"QuantitativeMRI.MESE_EPG","text":"MESE_EPG(T2,T1,delta,TE,ETL)\n\nCalculate EPG amplitudes of echos for a standard Multi-echo Spin-echo sequence     (same TE / refoc pulse along the echo train):\n\nT2\nT1\ndelta : delta B1 [0-1]\nTE\nETL : Echo train length\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.T1maps_mp2rage-Union{Tuple{T}, Tuple{Array{T}, AbstractVector, AbstractVector}} where T<:Real","page":"Home","title":"QuantitativeMRI.T1maps_mp2rage","text":"T1maps_mp2rage(T1map::Array{T},lookUpTable::AbstractVector, T1Range::AbstractVector) where T<:Real\n\nGenerates the MP2RAGE / UNI images from the T1 maps. Compute Lookup table from MP2RAGE parameters. \n\nkeywords radial = false means that only the central echo is used to compute the signal (standard method for cartesian acquisition) If radial = true, all the echoes are sum.\n\nArguments\n\nT1map::Array{T}\nlookUpTable::AbstractVector\nT1Range::AbstractVector\n\nReturns\n\nMP2\nT1Range\nlookUpTable\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.T1maps_mp2rage-Union{Tuple{T}, Tuple{Array{T}, ParamsMP2RAGE}} where T<:Real","page":"Home","title":"QuantitativeMRI.T1maps_mp2rage","text":"T1maps_MP2RAGE(T1map::Array{T},p::ParamsMP2RAGE;T1Range=1:10000,effInv = 0.96,radial=false) where T<:Real\n\nGenerates the MP2RAGE / UNI images from the T1 maps. Compute Lookup table from MP2RAGE parameters. \n\nkeywords radial = false means that only the central echo is used to compute the signal (standard method for cartesian acquisition) If radial = true, all the echoes are sum.\n\nArguments\n\nT1map::Array{T}\np::ParamsMP2RAGE\n\nKeywords\n\nT1Range = 1:10000\neffInv = 0.96\nradial = false \n\nReturns\n\nMP2\nT1Range\nlookUpTable\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.T2Fit_EpgNoise-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, Any, Any, Any}, Tuple{Array{T, N}, Any, Any, Any, Vector{Float64}}} where {T<:Real, N}","page":"Home","title":"QuantitativeMRI.T2Fit_EpgNoise","text":"T2Fit_EpgNoise(ima::Array{T,4}, T1,TE,ETL,x0::Vector{Float64}) where T<:Real\n\nFit the relaxation parameters T2 of a Multi-Spin Multi-Echo sequence with constant Delta TE and refocusing pulse. EPG is computed with MRIReco functions. In order to compute the gaussian noise standard deviation you need to know the number of coils l and apply the following equation :\n\nsigma_g = fracsigmasqrt2L\n\nArguments\n\nima::Array{T,N}: image where the echoes are in the last dimension\nt::Union{Vector{<:Real},StepRange{<:Real,<:Real}}: times vector in ms\nT1: T1 relaxation time\nTE: Echo Time\nETL: Echo Train Length\n\nKeywords\n\nReturns fitted maps with format (x,y,z, M0,T2,delta (b1), Noise)\n\nBibliography\n\nNoise\n\nCárdenas-Blanco A, Tejos C, Irarrazaval P, Cameron I. Noise in magnitude magnetic resonance images. Concepts Magn Reson Part A [Internet]. 2008 Nov;32A(6):409–16. Available from: http://doi.wiley.com/10.1002/cmr.a.20124\nFeng Y, He T, Gatehouse PD, Li X, Harith Alam M, Pennell DJ, et al. Improved MRI R 2 * relaxometry of iron-loaded liver with noise correction. Magn Reson Med [Internet]. 2013 Dec;70(6):1765–74. Available from: http://doi.wiley.com/10.1002/mrm.24607\n\nEPG\n\nMRIReco.jl implementation\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.T2Fit_Exp-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, AbstractVector{T}}, Tuple{Array{T, N}, AbstractVector{T}, Any}} where {T<:Real, N}","page":"Home","title":"QuantitativeMRI.T2Fit_Exp","text":"T2Fit_Exp(ima::Array{T,N},t::AbstractVector{T},p0=nothing) where {T<:Real,N}\n\nFit the relaxation parameters T2 with the equation : S(t) = M_0 exp(-fractT2).\n\nArguments\n\nima::Array{T,N}: image with dimension [x,...,t]. Last dimensions -> temporal dimension\nt::AbstractVector{<:Real}: times vector in ms\np0=nothing: starting values for fit, if empty p0=[maximum(ima),30]\n\nKeywords\n\nremovePoint::Bool=true: remove the first point before fitting\n\nReturns\n\nfit_params : parameter maps\nM₀ maps (no unit)\nT₂ maps (ms)\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.T2Fit_ExpNoise-Union{Tuple{N}, Tuple{T}, Tuple{Array{T, N}, AbstractVector{T}}, Tuple{Array{T, N}, AbstractVector{T}, Any}} where {T<:Real, N}","page":"Home","title":"QuantitativeMRI.T2Fit_ExpNoise","text":"T2Fit_ExpNoise(ima::Array{T,N},t::AbstractVector{<:Real},p0=nothing; kwargs...) where {T<:Real,N}\n\nFit the relaxation parameters T2 with the equation : S(t) = sqrt(M_0 exp(-fractT2))^2 + 2 L sigma_g^2 where L est le nombre de canaux, et sigma_g le bruit gaussien sur les image\n\nArguments\n\nima::Array{T,N}: image with dimension [x,...,t]. Last dimensions -> temporal dimension\nt::AbstractVector{<:Real}: times vector in ms\np0=nothing: starting values for fit, if empty p0=[maximum(ima),30,maximum(ima)*0.1]\n\nKeywords\n\nremovePoint::Bool=true: remove the first point before fitting\nL::Int=1: Number of coil elements\n\nReturns\n\nfit_params : parameter maps\nM₀ maps (no unit)\nT₂ maps (ms)\nNoise maps (no unit)\nfit_vec : fit objects for each pixels\n\nBibliography\n\nCárdenas-Blanco A, Tejos C, Irarrazaval P, Cameron I. Noise in magnitude magnetic resonance images. Concepts Magn Reson Part A [Internet]. 2008 Nov;32A(6):409–16. Available from: http://doi.wiley.com/10.1002/cmr.a.20124\nFeng Y, He T, Gatehouse PD, Li X, Harith Alam M, Pennell DJ, et al. Improved MRI R 2 * relaxometry of iron-loaded liver with noise correction. Magn Reson Med [Internet]. 2013 Dec;70(6):1765–74. Available from: http://doi.wiley.com/10.1002/mrm.24607\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.mp2rage_T1maps-Union{Tuple{T}, Tuple{Array{T}, ParamsMP2RAGE}} where T<:Real","page":"Home","title":"QuantitativeMRI.mp2rage_T1maps","text":"mp2rageT1maps(imMP2::Array{T},p::ParamsMP2RAGE;T1Range=1:10000,effInv = 0.96) where T <: Real\n\nCompute Lookup table from MP2RAGE parameters.  keywords radial = false means that only the central echo is used to compute the signal (standard method for cartesian acquisition) If radial = true, all the echoes are sum.\n\nArguments\n\nim_MP2::Array{T}\np::ParamsMP2RAGE\n\nKeywords\n\nT1Range = 1:10000\neffInv = 0.96\nradial = false \n\nReturns\n\nT1map\nT1Range\nlookUpTable\n\nBibliography\n\nMarques JP, Kober T, Krueger G, van der Zwaag W, Van de Moortele P-F, Gruetter R. MP2RAGE, a self bias-field corrected sequence for improved segmentation and T1-mapping at high field. NeuroImage 2010;49:1271–1281 doi: 10.1016/j.neuroimage.2009.10.002.\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.mp2rage_comb-Union{Tuple{Array{Complex{T}}}, Tuple{T}} where T<:Real","page":"Home","title":"QuantitativeMRI.mp2rage_comb","text":"mp2rage_comb(ima::Array{Complex{<:Real}})\nmp2rage_comb(ima_magn::Array{<:Real},ima_phase::Array{<:Real})\n\nCombine the image acquired at 2 differents inversion time (TI) in order to create a MP2RAGE image with the following equation. ima could be of any size but the last dimension needs to be the 2 TI.\n\nIf magnitude and phase image are passed to the function. It will combine them to create a complex image.\n\ntextMP2RAGE = Re(fracima_TI_1 times conj(ima_TI_2)ima_TI_1^2+ima_TI_2^2)\n\nArguments\n\nima::Array{Complex{<:Real}}: image of any dimension with TI = 2\nima_magn::Array{<:Real},: magnitude image of any dimension with TI = 2\nima_phase::Array{<:Real},: magnitude image of any dimension with TI = 2\n\nKeywords\n\nReturns\n\nMP2RAGE images\n\nBibliography\n\nMarques JP, Kober T, Krueger G, van der Zwaag W, Van de Moortele P-F, Gruetter R. MP2RAGE, a self bias-field corrected sequence for improved segmentation and T1-mapping at high field. NeuroImage 2010;49:1271–1281 doi: 10.1016/j.neuroimage.2009.10.002.\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.mp2rage_lookuptable_cartesian-Tuple{ParamsMP2RAGE}","page":"Home","title":"QuantitativeMRI.mp2rage_lookuptable_cartesian","text":"mp2rage_lookuptable(p::ParamsMP2RAGE;T1Range=1:0.5:10000,effInv = 0.96)\n\nCompute lookup table according to the MP2RAGE parameters\n\nArguments\n\np::ParamsMP2RAGE: MP2RAGE parameters structure\n\nKeywords\n\nT1Range : T1 range computed\neffInv : Inversion efficiency of the pulse\n\nReturns\n\nlookUpTable (NaN .= 0)\n\nBibliography\n\nMarques JP, Kober T, Krueger G, van der Zwaag W, Van de Moortele P-F, Gruetter R. MP2RAGE, a self bias-field corrected sequence for improved segmentation and T1-mapping at high field. NeuroImage 2010;49:1271–1281 doi: 10.1016/j.neuroimage.2009.10.002.\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.mp2rage_lookuptable_radial-Tuple{ParamsMP2RAGE}","page":"Home","title":"QuantitativeMRI.mp2rage_lookuptable_radial","text":"mp2rage_lookuptable_radial(p::ParamsMP2RAGE;T1Range=1:0.5:10000,effInv = 0.96)\n\nCompute lookup table according to the MP2RAGE parameters summing all the echoesl (mandatory for radial acquisition)\n\nArguments\n\np::ParamsMP2RAGE: MP2RAGE parameters structure\n\nKeywords\n\nT1Range : T1 range computed\neffInv : Inversion efficiency of the pulse\n\nReturns\n\nlookUpTable (NaN .= 0)\n\nBibliography\n\nMarques JP, Kober T, Krueger G, van der Zwaag W, Van de Moortele P-F, Gruetter R. MP2RAGE, a self bias-field corrected sequence for improved segmentation and T1-mapping at high field. NeuroImage 2010;49:1271–1281 doi: 10.1016/j.neuroimage.2009.10.002.\nFaller TL, Trotier AJ, Miraux S, Ribot EJ. Radial MP2RAGE sequence for rapid 3D T1 mapping of mouse abdomen: application to hepatic metastases. Eur Radiol. 2019 Nov;29(11):5844-5851. doi: 10.1007/s00330-019-06081-3. Epub 2019 Mar 19. PMID: 30888483.\n\n\n\n\n\n","category":"method"},{"location":"#QuantitativeMRI.residual_EpgNoise-Tuple{Vector{<:Real}, Vector{<:Real}, Any, Any, Any}","page":"Home","title":"QuantitativeMRI.residual_EpgNoise","text":"residual(x::Vector{<:Real}, ydata::Vector{<:Real},T1,TE,ETL)\n\nx -> Vector of parameter to fit :     - x[1] : M0     - x[2] : T2     - x[3] : delta     - x[4] : sigma\n\n\n\n\n\n","category":"method"}]
}
